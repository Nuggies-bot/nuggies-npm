# Src Classes

[_Documentation generated by Documatic_](https://www.documatic.com?377052553)

<!---Documatic-section-src.classes.v12.giveaways.replacePlaceholders-start--->
## src.classes.v12.giveaways.replacePlaceholders

<!---Documatic-section-replacePlaceholders-start--->
### Summary

Replace placeholders in given string.

<!---Documatic-block-src.classes.v12.giveaways.replacePlaceholders-start--->
<details>
	<summary><code>src.classes.v12.giveaways.replacePlaceholders</code> code snippet</summary>

```javascript
function replacePlaceholders(string, data, msg, winners = []) {
	const newString = string.replace(/{guildName}/g, msg.guild.name).replace(/{totalParticipants}/g, data.clickers.length).replace(/{prize}/g, data.prize).replace(/{winPercentage}/g, (winners.length / data.clickers.length) * 100).replace(/{giveawayURL}/g, `https://discord.com/channels/${msg.guild.id}/${msg.channel.id}/${data.messageID}`).replace(/{hostedBy}/g, msg.guild.members.cache.get(data.host).toString()).replace(/{winners}/g, winners.length > 0 ? winners.map(winner => `<@${winner}>`).join(', ') : 'none' || 'none');
	return newString;
}
```
</details>
<!---Documatic-block-src.classes.v12.giveaways.replacePlaceholders-end--->
<!---Documatic-section-replacePlaceholders-end--->
<!---Documatic-section-src.classes.v12.giveaways.replacePlaceholders-end--->

<!---Documatic-section-src.classes.v12.functions.handleButtons.exports-start--->
## src.classes.v12.functions.handleButtons.exports

<!---Documatic-section-exports-start--->
### Summary

This module exports a function that can be used to create custom messages for the giveaway button.

<!---Documatic-block-src.classes.v12.functions.handleButtons.exports-start--->
<details>
	<summary><code>src.classes.v12.functions.handleButtons.exports</code> code snippet</summary>

```javascript
module.exports = async (client, button) => {
	if (!button.guild) return;
	if (!client.customMessages || !client.customMessages.buttonRolesMessages) {
		client.customMessages = {
			buttonRolesMessages: defaultButtonRolesMessages,
			giveawayMessages: defaultGiveawayMessages,
		};
	}
	await button.clicker.fetch();
	const id = button.id;
	if (id.startsWith('giveaways')) {
		const tag = id.split('-');
		if (tag[1] === 'enter') {
			const data = await schema.findOne({ messageID: button.message.id });
			if (data.clickers.includes(button.clicker.user.id)) { return button.reply.send(client.customMessages.giveawayMessages.alreadyParticipated, true); }
			if (data.requirements.enabled) {
				if(data.requirements.roles) {
					const roles = data.requirements.roles.map(x => button.message.guild.members.cache.get(button.clicker.user.id).roles.cache.get(x));
					if (!roles[0]) {
						const requiredRoles = button.message.guild.roles.cache.filter(x => data.requirements.roles.includes(x.id)).filter(x => !button.message.guild.members.cache.get(button.clicker.user.id).roles.cache.get(x.id)).array().map(x => `\`${x.name}\``).join(', ');
						return button.reply.send(client.customMessages.giveawayMessages.nonoRole.replace(/{requiredRoles}/g, requiredRoles), true);
					}
				}
				if(data.requirements.amariweekly) {
					const amaridata = await utils.getAmariData(data.requirements.key, button.clicker.user.id, button.guild.id);
					if(parseInt(data.requirements.amariweekly) > parseInt(amaridata.weeklyExp)) {
						return button.reply.send(client.customMessages.giveawayMessages.noWeeklyExp, true);
					}
				}
				if(data.requirements.amarilevel) {
					const amaridata = await utils.getAmariData(data.requirements.key, button.clicker.user.id, button.guild.id);
					if(parseInt(data.requirements.amarilevel) > amaridata.level) {
						return button.reply.send(client.customMessages.giveawayMessages.noWeeklyExp, true);
					}
				}
			}
			if (!data.clickers.includes(button.clicker.user.id)) {
				data.clickers.push(button.clicker.user.id);
				data.save();
				return button.reply.send(client.customMessages.giveawayMessages.newParticipant.replace(/{winPercentage}/g, (1 / data.clickers.length) * 100).replace(/{totalParticipants}/g, data.clickers.length), true);
			}
			else {
				return button.reply.send(client.customMessages.giveawayMessages.alreadyParticipated, true);
			}
		}
		if (tag[1] === 'reroll') {
			if (button.clicker.user.id !== tag[2]) return button.reply.send('You Cannot Reroll This Giveaway, Only The Host Can', { ephemeral: true });
			try {
				button.reply.send('Rerolled!', true);
				win = await giveaways.reroll(client, button.message.id);
			}
			catch (err) {
				console.log(err);
				return button.message.channel.send('⚠️ **Unable To Find That Giveaway**');
			}
			if (!win.length) return button.message.channel.send(client.customMessages.giveawayMessages.nonoParticipants);
			button.message.channel.send(client.customMessages.giveawayMessages.rerolledMessage.replace(/{winner}/g, `<@${win}>`), { component: new MessageButton().setLabel('Giveaway').setURL(`https://discord.com/channels/${button.message.guild.id}/${button.message.channel.id}/${button.message.id}`).setStyle('url') });
		}
		if (tag[1] === 'end') {
			button.reply.defer();
			if (button.clicker.user.id !== tag[2]) return button.reply.send('You Cannot End This Giveaway, Only The Host Can', { ephemeral: true });
			await giveaways.endByButton(client, button.message.id, button);
		}
	}
	if (id.startsWith('br')) {
		let member;
		const fetchMem = await button.guild.members.fetch(button.clicker.member.id, false);
		if (fetchMem) member = button.guild.members.cache.get(button.clicker.member.id);
		await member.fetch(true);
		const role = id.split(':')[1];
		if (button.clicker.member.roles.cache.has(role)) {
			button.clicker.member.roles.remove(role);
			button.reply.send(client.customMessages.buttonRolesMessages.removeMessage.replace(/{role}/g, `<@&${role}>`), true);
		}
		else {
			button.clicker.member.roles.add(role);
			button.reply.send(client.customMessages.buttonRolesMessages.addMessage.replace(/{role}/g, `<@&${role}>`), true);
		}
	}
};
```
</details>
<!---Documatic-block-src.classes.v12.functions.handleButtons.exports-end--->
<!---Documatic-section-exports-end--->
<!---Documatic-section-src.classes.v12.functions.handleButtons.exports-end--->

<!---Documatic-section-src.classes.v12.functions.handleMenus.exports-start--->
## src.classes.v12.functions.handleMenus.exports

<!---Documatic-section-exports-start--->
### Summary

This module exports a menu that can be used to create an application.

<!---Documatic-block-src.classes.v12.functions.handleMenus.exports-start--->
<details>
	<summary><code>src.classes.v12.functions.handleMenus.exports</code> code snippet</summary>

```javascript
module.exports = async (client, menu) => {
	if (!menu.guild) return;
	if (!client.customMessages || !client.customMessages.dropdownRolesMessages) {
		client.customMessages = {
			dropdownRolesMessages: defaultDropdownRolesMessages,
		};
	}
	await menu.clicker.fetch();
	if (menu.id == 'app') {
		const app = menu.values[0];
		const data = await applications.getDataByGuild(menu.guild.id);
		if (!data) return menu.reply.send({ content: 'Something went wrong!', ephemeral: true });
		const last = data.responses.find(x => x.userID == menu.clicker.user.id);
		if (last) {
			if ((Date.now() - last.createdAt) < data.applicationCooldown) return menu.reply.send({ content: `You cannot create another application for ${ms((last.createdAt + data.applicationCooldown) - Date.now(), { long: true })}`, ephemeral: true });
		}
		const responses = data.responses.filter(x => x.userID == menu.clicker.user.id && x.accepted == undefined && x.declined == undefined);
		if (responses.length == data.maxApplicationsFromUser) return menu.reply.send({ content: 'You cannot submit any more responses as you have reached the limit', ephemeral: true });
		const index = await data.applications.find((application) => {
			return application.name === app;
		});
		let step = 0;
		const embed = new Discord.MessageEmbed().setColor('RANDOM').setTitle(`Application: ${app}`).setFooter(`Question: 1/${index.questions.length}`);
		const msg = await menu.clicker.user.send(embed.setDescription(index.questions[0]));
		const collector = msg.channel.createMessageCollector(m => !m.author.bot, { max: index.questions.length });
		const res = { userID: menu.clicker.user.id, answers: [], createdAt: Date.now(), app };
		collector.on('collect', m => {
			if (!m.content) return collector.stop('ERROR');
			res.answers
				.push({ question: index.questions[step], answer: m.content });
			step++;
			if (step == index.questions.length) {
				m.channel.send('Your application has been completed!');
				return collector.stop('DONE');
			}
			msg.channel.send(embed.setDescription(index.questions[step]).setFooter(`Question: ${step + 1}/${index.questions.length}`));
		});
		collector.on('end', async (msgs, reason) => {
			if (reason == 'ERROR') {
				return msg.channel.send('That is not a valid answer');
			}
			if (reason == 'DONE') {
				const newdata = await applications.getDataByGuild(menu.message.guild.id);
				newdata.responses.push(res);
				await newdata.save();
				const c = await client.channels.fetch(data.responseChannel, true, false);
				if (!c) return;
				c.send({ embed: new Discord.MessageEmbed().setTitle('New response').setDescription(`Application: ${app}\nUser: ${menu.clicker.user} - \`${menu.clicker.user.id}\``).addFields(res.answers.map(x => { return { name: `Question: ${x.question}`, value: `Answer: ${x.answer}`, inline: true }; })).setColor('RANDOM').setFooter(menu.clicker.user.tag, menu.clicker.user.displayAvatarURL()) });
			}
		});
		menu.reply.send({ content: `Check your DMs! Or click this link ${msg.url}`, ephemeral: true });
	}
	if (menu.id.startsWith('dr')) {
		const type = menu.id.split('-')[1];
		let member;
		const fetchMem = await menu.guild.members.fetch(menu.clicker.id, false);
		if (fetchMem) member = menu.guild.members.cache.get(menu.clicker.id);
		await member.fetch(true);
		if (type === 'multiple') {
			let msg = '';
			for(let i = 0; i < menu.values.length; i++) {
				const role = menu.values[i];
				if (menu.clicker.member.roles.cache.has(role)) {
					menu.clicker.member.roles.remove(role);
					msg += client.customMessages.dropdownRolesMessages.removeMessage.replace(/{role}/g, `<@&${role}>`) + '\n';
				}
				else {
					menu.clicker.member.roles.add(role);
					msg += client.customMessages.dropdownRolesMessages.addMessage.replace(/{role}/g, `<@&${role}>`) + '\n';
				}
			}
			menu.reply.send({ content: msg, ephemeral: true });
		}
		else if (type === 'single') {
			if (menu.clicker.member.roles.cache.has(menu.values[0])) {
				menu.clicker.member.roles.remove(menu.values[0]);
				menu.reply.send({ content: client.customMessages.dropdownRolesMessages.removeMessage.replace(/{role}/g, `<@&${menu.values[0]}>`), ephemeral: true });
			}
			else {
				menu.clicker.member.roles.add(menu.values[0]);
				menu.reply.send({ content: client.customMessages.dropdownRolesMessages.addMessage.replace(/{role}/g, `<@&${menu.values[0]}>`), ephemeral: true });
			}
		}
	}
};
```
</details>
<!---Documatic-block-src.classes.v12.functions.handleMenus.exports-end--->
<!---Documatic-section-exports-end--->
<!---Documatic-section-src.classes.v12.functions.handleMenus.exports-end--->

<!---Documatic-section-src.classes.v13.giveaways.replacePlaceholders-start--->
## src.classes.v13.giveaways.replacePlaceholders

<!---Documatic-section-replacePlaceholders-start--->
### Summary

Replace placeholders in given string.

<!---Documatic-block-src.classes.v13.giveaways.replacePlaceholders-start--->
<details>
	<summary><code>src.classes.v13.giveaways.replacePlaceholders</code> code snippet</summary>

```javascript
function replacePlaceholders(string, data, msg, winners = []) {
	const newString = string.replace(/{guildName}/g, msg.guild.name).replace(/{totalParticipants}/g, data.clickers.length).replace(/{prize}/g, data.prize).replace(/{winPercentage}/g, (winners.length / data.clickers.length) * 100).replace(/{giveawayURL}/g, `https://discord.com/channels/${msg.guild.id}/${msg.channel.id}/${data.messageID}`).replace(/{hostedBy}/g, msg.guild.members.cache.get(data.host).toString()).replace(/{winners}/g, winners.length > 0 ? winners.map(winner => `<@${winner}>`).join(', ') : 'none' || 'none');
	return newString;
}
```
</details>
<!---Documatic-block-src.classes.v13.giveaways.replacePlaceholders-end--->
<!---Documatic-section-replacePlaceholders-end--->
<!---Documatic-section-src.classes.v13.giveaways.replacePlaceholders-end--->

<!---Documatic-section-src.classes.v13.functions.handleButtons.exports-start--->
## src.classes.v13.functions.handleButtons.exports

<!---Documatic-section-exports-start--->
### Summary

This module exports a function that can be used to provide custom messages for the giveaway button.

<!---Documatic-block-src.classes.v13.functions.handleButtons.exports-start--->
<details>
	<summary><code>src.classes.v13.functions.handleButtons.exports</code> code snippet</summary>

```javascript
module.exports = async (client, button) => {
	if (!button.guild) return;
	if (!client.customMessages || !client.customMessages.buttonRolesMessages) {
		client.customMessages = {
			buttonRolesMessages: defaultButtonRolesMessages,
			giveawayMessages: defaultGiveawayMessages,
		};
	}
	await button.member.fetch();
	const id = button.customId;
	if (id.startsWith('giveaways')) {
		const tag = id.split('-');
		if (tag[1] === 'enter') {
			const data = await schema.findOne({ messageID: button.message.id });
			if (data.requirements.enabled) {
				let amaridata = null;
				if(data.requirements.amariweekly || data.requirements.amarilevel) amaridata = await utils.getAmariData(data.requirements.key, button.user.id, button.guild.id);
				if(data.requirements.roles) {
					const roles = data.requirements.roles.map(x => button.message.guild.members.cache.get(button.user.id).roles.cache.get(x));
					if (!roles[0]) {
						const requiredRoles = button.message.guild.roles.cache.filter(x => data.requirements.roles.includes(x.id)).filter(x => !button.message.guild.members.cache.get(button.user.id).roles.cache.get(x.id)).map(x => `\`${x.name}\``).join(', ');
						return button.reply({ content: client.customMessages.giveawayMessages.nonoRole.replace(/{requiredRoles}/g, requiredRoles), ephemeral : true });
					}
				}
				if(data.requirements.amariweekly) {
					if(parseInt(data.requirements.amariweekly) > parseInt(amaridata.weeklyExp)) {
						return button.reply({ content: client.customMessages.giveawayMessages.noWeeklyExp, ephemeral: true });
					}
				}
				if(data.requirements.amarilevel) {
					if(parseInt(data.requirements.level) > amaridata.level) {
						return button.reply({ content: client.customMessages.giveawayMessages.noLevel, ephemeral: true });
					}
				}
			}
			if (!data.clickers.includes(button.user.id)) {
				data.clickers.push(button.user.id);
				data.save();
				return button.reply({ content: client.customMessages.giveawayMessages.newParticipant.replace(/{winPercentage}/g, (1 / data.clickers.length) * 100).replace(/{totalParticipants}/g, data.clickers.length), ephemeral: true });
			}
			else {
				return button.reply({ content: client.customMessages.giveawayMessages.alreadyParticipated, ephemeral: true });
			}
		}
		if (tag[1] === 'reroll') {
			if (button.user.id !== tag[2]) return button.reply({ ephemeral: true, content: 'You Cannot Reroll This Giveaway, Only The Host Can' });
			try {
				button.reply({ content: 'Rerolled!', ephemeral: true });
				win = await giveaways.reroll(client, button.message.id);
			}
			catch (err) {
				console.log(err);
				return button.message.channel.send('⚠️ **Unable To Find That Giveaway**');
			}
			if (!win.length) return button.message.channel.send(client.customMessages.giveawayMessages.nonoParticipants);
			button.message.channel.send({ content: client.customMessages.giveawayMessages.rerolledMessage.replace(/{winner}/g, `<@${win}>`), components: [new Discord.MessageActionRow().addComponents([new Discord.MessageButton().setLabel('Giveaway').setURL(`https://discord.com/channels/${button.message.guild.id}/${button.message.channel.id}/${button.message.id}`).setStyle('LINK')])] });
		}
		if (tag[1] === 'end') {
			if (button.user.id !== tag[2]) return button.reply({ content: 'You Cannot End This Giveaway, Only The Host Can', ephemeral: true });
			await giveaways.endByButton(client, button.message.id, button);
		}
	}
	if (id.startsWith('br')) {
		let member;
		const fetchMem = await button.guild.members.fetch(button.member.id, false);
		if (fetchMem) member = button.guild.members.cache.get(button.member.id);
		await member.fetch(true);
		const role = id.split(':')[1];
		if (button.member.roles.cache.has(role)) {
			button.member.roles.remove(role);
			button.reply({ content: client.customMessages.buttonRolesMessages.removeMessage.replace(/{role}/g, `<@&${role}>`), ephemeral: true });
		}
		else {
			button.member.roles.add(role);
			button.reply({ content: client.customMessages.buttonRolesMessages.addMessage.replace(/{role}/g, `<@&${role}>`), ephemeral: true });
		}
	}
};
```
</details>
<!---Documatic-block-src.classes.v13.functions.handleButtons.exports-end--->
<!---Documatic-section-exports-end--->
<!---Documatic-section-src.classes.v13.functions.handleButtons.exports-end--->

<!---Documatic-section-src.classes.v13.functions.handleMenus.exports-start--->
## src.classes.v13.functions.handleMenus.exports

<!---Documatic-section-exports-start--->
### Summary

Displays a menu in the guild.

<!---Documatic-block-src.classes.v13.functions.handleMenus.exports-start--->
<details>
	<summary><code>src.classes.v13.functions.handleMenus.exports</code> code snippet</summary>

```javascript
module.exports = async (client, menu) => {
	if (!menu.guild) return;
	if (!client.customMessages || !client.customMessages.dropdownRolesMessages) {
		client.customMessages = {
			dropdownRolesMessages: defaultDropdownRolesMessages,
		};
	}
	await menu.member.fetch();
	if (menu.customId == 'app') {
		const app = menu.values[0];
		const data = await applications.getDataByGuild(menu.guild.id);
		if (!data) return menu.reply({ content: 'Something went wrong!', ephemeral: true });
		const last = data.responses.find(x => x.userID == menu.user.id);
		if (last) {
			if ((Date.now() - last.createdAt) < data.applicationCooldown) return menu.reply({ content: `You cannot create another application for ${ms((last.createdAt + data.applicationCooldown) - Date.now(), { long: true })}`, ephemeral: true });
		}
		const responses = data.responses.filter(x => x.userID == menu.user.id && x.accepted == undefined && x.declined == undefined);
		if (responses.length == data.maxApplicationsFromUser) return menu.reply({ content: 'You cannot submit any more responses as you have reached the limit', ephemeral: true });
		const index = await data.applications.find((application) => {
			return application.name === app;
		});
		let step = 0;
		const embed = new Discord.MessageEmbed().setColor('RANDOM').setTitle(`Application: ${app}`).setFooter(`Question: 1/${index.questions.length}`);
		const msg = await menu.user.send({ embeds: [embed.setDescription(index.questions[0])] });
		const collector = msg.channel.createMessageCollector({ filter: m => !m.author.bot, max: index.questions.length });
		const res = { userID: menu.user.id, answers: [], createdAt: Date.now(), app };
		collector.on('collect', m => {
			if (!m.content) return collector.stop('ERROR');
			res.answers
				.push({ question: index.questions[step], answer: m.content });
			step++;
			if (step == index.questions.length) {
				m.channel.send('Your application has been completed!');
				return collector.stop('DONE');
			}
			msg.channel.send({ embeds: [embed.setDescription(index.questions[step]).setFooter(`Question: ${step + 1}/${index.questions.length}`)] });
		});
		collector.on('end', async (msgs, reason) => {
			if (reason == 'ERROR') {
				return msg.channel.send('That is not a valid answer');
			}
			if (reason == 'DONE') {
				const newdata = await applications.getDataByGuild(menu.message.guild.id);
				newdata.responses.push(res);
				await newdata.save();
				const c = await client.channels.fetch(data.responseChannel, true, false);
				if (!c) return;
				c.send({ embeds: [new Discord.MessageEmbed().setTitle('New response').setDescription(`Application: ${app}\nUser: ${menu.user} - \`${menu.user.id}\``).addFields(res.answers.map(x => { return { name: `Question: ${x.question}`, value: `Answer: ${x.answer}`, inline: true }; })).setColor('RANDOM').setFooter(menu.user.tag, menu.user.displayAvatarURL())] });
			}
		});
		menu.reply({ content: `Check your DMs! Or click this link ${msg.url}`, ephemeral: true });
	}

	if (menu.customId.startsWith('dr-')) {
		const type = menu.customId.split('-')[1];
		let member;
		const fetchMem = await menu.guild.members.fetch(menu.member.id, false);
		if (fetchMem) member = menu.guild.members.cache.get(menu.member.id);
		await member.fetch(true);
		if (type === 'multiple') {
			let msg = '';
			for(let i = 0; i < menu.values.length; i++) {
				const role = menu.values[i];
				if (menu.member.roles.cache.has(role)) {
					menu.member.roles.remove(role);
					msg += client.customMessages.dropdownRolesMessages.removeMessage.replace(/{role}/g, `<@&${role}>`) + '\n';
				}
				else {
					menu.member.roles.add(role);
					msg += client.customMessages.dropdownRolesMessages.addMessage.replace(/{role}/g, `<@&${role}>`) + '\n';
				}
			}
			menu.reply({ content: msg, ephemeral: true });
		}
		else if (type === 'single') {
			if (menu.member.roles.cache.has(menu.values[0])) {
				menu.member.roles.remove(menu.values[0]);
				menu.reply({ content: client.customMessages.dropdownRolesMessages.removeMessage.replace(/{role}/g, `<@&${menu.values[0]}>`), ephemeral: true });
			}
			else {
				menu.member.roles.add(menu.values[0]);
				menu.reply({ content: client.customMessages.dropdownRolesMessages.addMessage.replace(/{role}/g, `<@&${menu.values[0]}>`), ephemeral: true });
			}
		}
	}
};
```
</details>
<!---Documatic-block-src.classes.v13.functions.handleMenus.exports-end--->
<!---Documatic-section-exports-end--->
<!---Documatic-section-src.classes.v13.functions.handleMenus.exports-end--->

[_Documentation generated by Documatic_](https://www.documatic.com?377052553)